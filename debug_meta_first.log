   Compiling prolog2 v0.1.0 (/home/james/Programming Projects/prolog2)
warning: unused imports: `Acquire`, `Mutex`, and `Relaxed`
 --> src/heap/symbol_db.rs:6:24
  |
6 |             Ordering::{Acquire, Relaxed},
  |                        ^^^^^^^  ^^^^^^^
7 |         },
8 |         Arc, Mutex, RwLock,
  |              ^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused imports: `DerefMut`, `Deref`, `PoisonError`, and `RwLock`
 --> src/heap/query_heap.rs:1:17
  |
1 | use std::{ops::{Deref, DerefMut, Index, IndexMut, Range}, sync::{atomic::{AtomicUsize,Ordering::Acquire}, Arc, PoisonError, RwLock, RwLoc...
  |                 ^^^^^  ^^^^^^^^                                                                                ^^^^^^^^^^^  ^^^^^^

warning: unused import: `PROG_HEAP`
 --> src/heap/query_heap.rs:3:36
  |
3 | use super::heap::{Cell, Heap, Tag, PROG_HEAP};
  |                                    ^^^^^^^^^

warning: unused import: `fmt::format`
 --> src/parser/build_tree.rs:3:11
  |
3 | use std::{fmt::format, str};
  |           ^^^^^^^^^^^

warning: unused import: `fsize::fsize`
 --> src/parser/build_tree.rs:5:5
  |
5 | use fsize::fsize;
  |     ^^^^^^^^^^^^

warning: unused import: `fsize::fsize`
 --> src/parser/tokeniser.rs:1:5
  |
1 | use fsize::fsize;
  |     ^^^^^^^^^^^^

warning: unused import: `std::str::CharIndices`
 --> src/parser/tokeniser.rs:2:5
  |
2 | use std::str::CharIndices;
  |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `mem`
 --> src/parser/execute_tree.rs:1:33
  |
1 | use std::{collections::HashMap, mem};
  |                                 ^^^

warning: unused imports: `Cell`, `EMPTY_LIS`, `Tag`, `query_heap::QueryHeap`, `resolution::proof::Proof`, `self`, `self`, and `symbol_db::SymbolDB`
 --> src/parser/execute_tree.rs:8:12
  |
8 |     heap::{Cell, Heap, Tag, EMPTY_LIS}, query_heap::QueryHeap, symbol_db::SymbolDB
  |            ^^^^        ^^^  ^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^
9 | }, program::{clause::{self, Clause}, predicate_table::{self, PredicateTable}}, resolution::proof::Proof};
  |                       ^^^^                             ^^^^                    ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Layout`, `alloc`, `dealloc`, and `ptr::copy_nonoverlapping`
 --> src/program/clause.rs:2:13
  |
2 |     alloc::{alloc, dealloc, Layout},
  |             ^^^^^  ^^^^^^^  ^^^^^^
3 |     ops::Deref,
4 |     ptr::copy_nonoverlapping, sync::Arc,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `program::predicate_table::SymbolArity`
 --> src/program/hypothesis.rs:6:31
  |
6 | use crate::{heap::heap::Heap, program::predicate_table::SymbolArity};
  |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CON_PTR`
 --> src/resolution/unification.rs:6:36
  |
6 | use crate::heap::heap::{Heap, Tag, CON_PTR};
  |                                    ^^^^^^^

warning: unused imports: `Constraints` and `self`
 --> src/resolution/proof.rs:8:22
  |
8 |         hypothesis::{Constraints, Hypothesis},
  |                      ^^^^^^^^^^^
9 |         predicate_table::{self, Predicate, PredicateTable},
  |                           ^^^^

warning: unused import: `collections::HashMap`
  --> src/main.rs:10:5
   |
10 |     collections::HashMap,
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `clause::Clause`, `self`, `self`, and `self`
  --> src/main.rs:23:22
   |
23 |         query_heap::{self, QueryHeap},
   |                      ^^^^
...
32 |         clause::Clause,
   |         ^^^^^^^^^^^^^^
33 |         predicate_table::{self, PredicateTable},
   |                           ^^^^
34 |     },
35 |     resolution::proof::{self, Proof},
   |                         ^^^^

warning: variable does not need to be mutable
   --> src/heap/heap.rs:195:48
    |
195 |     fn copy_term(&mut self, other: &impl Heap, mut addr: usize) -> usize {
    |                                                ----^^^^
    |                                                |
    |                                                help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `len`
   --> src/heap/heap.rs:226:24
    |
226 |             (Tag::Tup, len) => todo!(),
    |                        ^^^ help: if this is intentional, prefix it with an underscore: `_len`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `len`
   --> src/heap/heap.rs:227:24
    |
227 |             (Tag::Set, len) => todo!(),
    |                        ^^^ help: if this is intentional, prefix it with an underscore: `_len`

warning: unused variable: `pointer`
   --> src/heap/heap.rs:228:24
    |
228 |             (Tag::Ref, pointer) => panic!(),
    |                        ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pointer`

warning: unused variable: `len1`
   --> src/heap/heap.rs:251:25
    |
251 |             ((Tag::Tup, len1), (Tag::Tup, len2)) => todo!(),
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_len1`

warning: unused variable: `len2`
   --> src/heap/heap.rs:251:43
    |
251 |             ((Tag::Tup, len1), (Tag::Tup, len2)) => todo!(),
    |                                           ^^^^ help: if this is intentional, prefix it with an underscore: `_len2`

warning: unused variable: `len1`
   --> src/heap/heap.rs:252:25
    |
252 |             ((Tag::Set, len1), (Tag::Set, len2)) => todo!(),
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_len1`

warning: unused variable: `len2`
   --> src/heap/heap.rs:252:43
    |
252 |             ((Tag::Set, len1), (Tag::Set, len2)) => todo!(),
    |                                           ^^^^ help: if this is intentional, prefix it with an underscore: `_len2`

warning: unreachable pattern
   --> src/parser/build_tree.rs:184:13
    |
184 |             _ => Err(format!("Uh oh \"{}\" confused me", self.peek().unwrap())),
    |             ^ no value can reach this
    |
note: multiple earlier patterns match some of the same values
   --> src/parser/build_tree.rs:184:13
    |
131 |             "{" => {
    |             --- matches some of the same values
...
140 |             "[" => {
    |             --- matches some of the same values
...
153 |             "[]" => {
    |             ---- matches some of the same values
...
157 |             "{}" => {
    |             ---- matches some of the same values
...
184 |             _ => Err(format!("Uh oh \"{}\" confused me", self.peek().unwrap())),
    |             ^ ...and 2 other patterns collectively make this unreachable
    = note: `#[warn(unreachable_patterns)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
  --> src/parser/tokeniser.rs:26:24
   |
26 | pub fn remove_comments(mut file: String) -> Result<String, String> {
   |                        ----^^^^
   |                        |
   |                        help: remove this `mut`

warning: variable does not need to be mutable
  --> src/parser/tokeniser.rs:28:9
   |
28 |     let mut i = 0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `i`
  --> src/parser/tokeniser.rs:28:9
   |
28 |     let mut i = 0;
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `terms`
  --> src/parser/execute_tree.rs:69:35
   |
69 |             TreeClause::Directive(terms) => todo!(),
   |                                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_terms`

warning: unused variable: `clauses`
   --> src/program/predicate_table.rs:142:39
    |
142 |             if let Predicate::Clauses(clauses) = self.remove(predicate_idx).predicate {
    |                                       ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_clauses`

warning: unused variable: `len`
  --> src/program/clause.rs:45:13
   |
45 |         let len = literals.len();
   |             ^^^ help: if this is intentional, prefix it with an underscore: `_len`

warning: unused variable: `heap`
  --> src/program/hypothesis.rs:26:51
   |
26 |     pub fn push_clause(&mut self, clause: Clause, heap: &impl Heap, constraints: Constraints) {
   |                                                   ^^^^ help: if this is intentional, prefix it with an underscore: `_heap`

warning: unreachable pattern
   --> src/resolution/unification.rs:170:65
    |
170 |         (Tag::Ref, Tag::Lis | Tag::Func | Tag::Set | Tag::Tup | Tag::Lis) => {
    |                    -------- matches all the relevant values     ^^^^^^^^ no value can reach this

warning: unreachable pattern
   --> src/resolution/unification.rs:174:55
    |
174 |         (Tag::Lis | Tag::Func | Tag::Set | Tag::Tup | Tag::Lis, Tag::Ref) => {
    |          -------- matches all the relevant values     ^^^^^^^^ no value can reach this

warning: variable does not need to be mutable
   --> src/resolution/unification.rs:207:5
    |
207 |     mut binding: Substitution,
    |     ----^^^^^^^
    |     |
    |     help: remove this `mut`

warning: unused variable: `heap`
   --> src/resolution/unification.rs:206:5
    |
206 |     heap: &impl Heap,
    |     ^^^^ help: if this is intentional, prefix it with an underscore: `_heap`

warning: unused variable: `binding`
   --> src/resolution/unification.rs:207:5
    |
207 |     mut binding: Substitution,
    |     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_binding`

warning: unused variable: `addr_1`
   --> src/resolution/unification.rs:208:5
    |
208 |     addr_1: usize,
    |     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_addr_1`

warning: unused variable: `addr_2`
   --> src/resolution/unification.rs:209:5
    |
209 |     addr_2: usize,
    |     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_addr_2`

warning: unused variable: `arg_id`
  --> src/resolution/build.rs:38:20
   |
38 |         (Tag::Arg, arg_id) => build_arg(heap, substitution, meta_vars, src_addr),
   |                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_arg_id`

warning: unused variable: `new_ptr`
  --> src/resolution/build.rs:41:17
   |
41 |             let new_ptr = build_list(heap, substitution, meta_vars, ptr);
   |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_ptr`

warning: unused variable: `choices`
  --> src/resolution/proof.rs:67:17
   |
67 |             let choices: Vec<Clause> = Vec::new();
   |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_choices`

warning: unused variable: `config`
   --> src/resolution/proof.rs:293:54
    |
293 |     pub fn new(heap: QueryHeap<'a>, goals: &[usize], config: Config) -> Self {
    |                                                      ^^^^^^ help: if this is intentional, prefix it with an underscore: `_config`

warning: function `continue_proof` is never used
  --> src/main.rs:65:4
   |
65 | fn continue_proof() -> bool {
   |    ^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: static `RUN_NEW` is never used
  --> src/heap/symbol_db.rs:32:8
   |
32 | static RUN_NEW: AtomicBool = AtomicBool::new(true);
   |        ^^^^^^^

warning: associated functions `get_symbol` and `see_var_map` are never used
   --> src/heap/symbol_db.rs:91:12
    |
 44 | impl SymbolDB {
    | ------------- associated functions in this implementation
...
 91 |     pub fn get_symbol(id: usize, heap_id: usize) -> String {
    |            ^^^^^^^^^^
...
118 |     pub fn see_var_map() {
    |            ^^^^^^^^^^^

warning: constant `CON_PTR` is never used
  --> src/heap/heap.rs:35:11
   |
35 | pub const CON_PTR: usize = isize::MAX as usize;
   |           ^^^^^^^

warning: constant `FALSE` is never used
  --> src/heap/heap.rs:36:11
   |
36 | pub const FALSE: Cell = (Tag::Con, CON_PTR);
   |           ^^^^^

warning: constant `TRUE` is never used
  --> src/heap/heap.rs:37:11
   |
37 | pub const TRUE: Cell = (Tag::Con, CON_PTR + 1);
   |           ^^^^

warning: multiple methods are never used
   --> src/heap/heap.rs:49:8
    |
 40 | pub trait Heap: IndexMut<usize, Output = Cell> + Index<Range<usize>, Output = [Cell]> {
    |           ---- methods in this trait
...
 49 |     fn set_arg(&mut self, value: usize) -> usize {
    |        ^^^^^^^
...
157 |     fn normalise_args(&mut self, addr: usize, args: &[usize]) {
    |        ^^^^^^^^^^^^^^
...
176 |     fn copy_complex(&mut self, other: &impl Heap, mut addr: usize, update_addr: &mut usize) {
    |        ^^^^^^^^^^^^
...
185 |     fn copy_simple(&mut self, other: &impl Heap, mut addr: usize, update_addr: &usize) {
    |        ^^^^^^^^^^^
...
195 |     fn copy_term(&mut self, other: &impl Heap, mut addr: usize) -> usize {
    |        ^^^^^^^^^
...
236 |     fn term_equal(&self, mut addr1: usize, mut addr2: usize) -> bool {
    |        ^^^^^^^^^^
...
273 |     fn print_heap(&self) {
    |        ^^^^^^^^^^

warning: static `PROG_HEAP` is never used
   --> src/heap/heap.rs:415:19
    |
415 | pub(crate) static PROG_HEAP: RwLock<Vec<Cell>> = RwLock::new(Vec::new());
    |                   ^^^^^^^^^

warning: field `arg_regs` is never read
 --> src/heap/query_heap.rs:9:5
  |
7 | pub struct QueryHeap<'a> {
  |            --------- field in this struct
8 |     id: usize,
9 |     arg_regs: [Cell; 64],
  |     ^^^^^^^^

warning: method `get_cells` is never used
  --> src/heap/query_heap.rs:32:12
   |
16 | impl<'a> QueryHeap<'a> {
   | ---------------------- method in this implementation
...
32 |     pub fn get_cells(self) -> Vec<Cell>{
   |            ^^^^^^^^^

warning: method `print_state` is never used
  --> src/parser/build_tree.rs:74:8
   |
30 | impl TokenStream {
   | ---------------- method in this implementation
...
74 |     fn print_state(&self) {
   |        ^^^^^^^^^^^

warning: associated functions `is_numeric`, `is_atom_var`, and `is_unit` are never used
  --> src/parser/term.rs:38:8
   |
16 | impl Unit {
   | --------- associated functions in this implementation
...
38 |     fn is_numeric(token: &str) -> bool {
   |        ^^^^^^^^^^
...
42 |     fn is_atom_var(token: &str) -> bool {
   |        ^^^^^^^^^^^
...
46 |     fn is_unit(token: &str) -> bool {
   |        ^^^^^^^

warning: associated function `pre_encode_complex_terms` is never used
   --> src/parser/term.rs:173:8
    |
134 | impl Term {
    | --------- associated function in this implementation
...
173 |     fn pre_encode_complex_terms(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^

warning: enum `ParseError` is never used
 --> src/parser/tokeniser.rs:4:6
  |
4 | enum ParseError {
  |      ^^^^^^^^^^

warning: constant `INFIX_ORDER` is never used
  --> src/parser/tokeniser.rs:15:7
   |
15 | const INFIX_ORDER: &[&[&str]] = &[
   |       ^^^^^^^^^^^

warning: function `remove_comments` is never used
  --> src/parser/tokeniser.rs:26:8
   |
26 | pub fn remove_comments(mut file: String) -> Result<String, String> {
   |        ^^^^^^^^^^^^^^^

warning: variants `True`, `False`, and `Binding` are never constructed
 --> src/predicate_modules/mod.rs:7:5
  |
6 | pub enum PredReturn {
  |          ---------- variants in this enum
7 |     True,
  |     ^^^^
8 |     False,
  |     ^^^^^
9 |     Binding(Vec<(usize, usize)>),
  |     ^^^^^^^

warning: associated function `bool` is never used
  --> src/predicate_modules/mod.rs:13:12
   |
12 | impl PredReturn {
   | --------------- associated function in this implementation
13 |     pub fn bool(value: bool) -> PredReturn {
   |            ^^^^

warning: type alias `PredicateModule` is never used
  --> src/predicate_modules/mod.rs:25:10
   |
25 | pub type PredicateModule = Vec<(&'static str, usize, PredicateFunction)>;
   |          ^^^^^^^^^^^^^^^

warning: function `load_predicate_module` is never used
  --> src/predicate_modules/mod.rs:27:8
   |
27 | pub fn load_predicate_module(
   |        ^^^^^^^^^^^^^^^^^^^^^

warning: variant `Function` is never constructed
  --> src/program/predicate_table.rs:17:5
   |
16 | pub enum Predicate {
   |          --------- variant in this enum
17 |     Function(PredicateFunction),
   |     ^^^^^^^^
   |
   = note: `Predicate` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `insert_predicate_function` and `remove_predicate` are never used
   --> src/program/predicate_table.rs:66:12
    |
 40 | impl PredicateTable {
    | ------------------- methods in this implementation
...
 66 |     pub fn insert_predicate_function(
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^
...
140 |     pub fn remove_predicate(&mut self, symbol_arity: SymbolArity) {
    |            ^^^^^^^^^^^^^^^^

warning: method `unset` is never used
  --> src/program/clause.rs:17:12
   |
12 | impl BitFlag64 {
   | -------------- method in this implementation
...
17 |     pub fn unset(&mut self, idx: usize) {
   |            ^^^^^

warning: function `build_ref` is never used
  --> src/resolution/build.rs:68:4
   |
68 | fn build_ref() {}
   |    ^^^^^^^^^

warning: function `triangular` is never used
  --> src/resolution/proof.rs:18:4
   |
18 | fn triangular(n: usize) -> usize {
   |    ^^^^^^^^^^

warning: field `goal_count` is never read
   --> src/resolution/proof.rs:285:5
    |
282 | pub struct Proof<'a> {
    |            ----- field in this struct
...
285 |     goal_count: u8,
    |     ^^^^^^^^^^

warning: unused `Result` that must be used
  --> src/predicate_modules/mod.rs:32:9
   |
32 |         predicate_table.insert_predicate_function((SymbolDB::set_const((*symbol).to_string()),*arity),*pred_fn);
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` (part of `#[warn(unused)]`) on by default
help: use `let _ = ...` to ignore the resulting value
   |
32 |         let _ = predicate_table.insert_predicate_function((SymbolDB::set_const((*symbol).to_string()),*arity),*pred_fn);
   |         +++++++

warning: function pointer comparisons do not produce meaningful results since their addresses are not guaranteed to be unique
  --> src/program/predicate_table.rs:17:14
   |
15 | #[derive(PartialEq, Eq, Debug, Clone)]
   |          --------- in this derive macro expansion
16 | pub enum Predicate {
17 |     Function(PredicateFunction),
   |              ^^^^^^^^^^^^^^^^^
   |
   = note: the address of the same function can vary between different codegen units
   = note: furthermore, different functions could have the same address after being merged together
   = note: for more information visit <https://doc.rust-lang.org/nightly/core/ptr/fn.fn_addr_eq.html>
   = note: `#[warn(unpredictable_function_pointer_comparisons)]` on by default

warning: `prolog2` (bin "prolog2") generated 70 warnings (run `cargo fix --bin "prolog2" -p prolog2` to apply 39 suggestions)
    Finished `dev` profile [optimized + debuginfo] target(s) in 0.42s
     Running `target/debug/prolog2`
[TRY] goal=ancestor(ken,james) addr=40
[MATCH] depth=0 goal=ancestor(ken,james) clause=P(X,Y):-Q(X,Y)., choices_remaining=1
[ADD_CLAUSE] depth=0 goal=ancestor(ken,james) clause=ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2).
[HYPOTHESIS] ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2).

[TRY] goal=Ref_49(ken,james) addr=48
[MATCH] depth=1 goal=Ref_49(ken,james) clause=P(X,Y):-Q(X,Y)., choices_remaining=6
[ADD_CLAUSE] depth=1 goal=Ref_49(ken,james) clause=pred_1(Arg_1,Arg_2):-Ref_62(Arg_1,Arg_2).
[INVENT_PRED] invented predicate for goal=Ref_49(ken,james)
[HYPOTHESIS] ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2).
pred_1(Arg_1,Arg_2):-Ref_62(Arg_1,Arg_2).

[TRY] goal=Ref_62(ken,james) addr=61
[NO_MATCH] depth=2 goal=Ref_62(ken,james) tried 7 choices, Originally had 7 choices
[UNDO_TRY] goal=Ref_49(ken,james) addr=48
[UNDO_CLAUSE] depth=1 clause=pred_1(Arg_1,Arg_2):-Ref_62(Arg_1,Arg_2).
[RETRY] goal=Ref_49(ken,james) addr=48
[MATCH] depth=1 goal=Ref_49(ken,james) clause=P(X,Y):-Q(X,Z),P(Z,Y)., choices_remaining=5
[ADD_CLAUSE] depth=1 goal=Ref_49(ken,james) clause=pred_1(Arg_1,Arg_2):-Ref_75(Arg_1,Arg_4),pred_1(Arg_4,Arg_2).
[INVENT_PRED] invented predicate for goal=Ref_49(ken,james)
[HYPOTHESIS] ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2).
pred_1(Arg_1,Arg_2):-Ref_75(Arg_1,Arg_4),pred_1(Arg_4,Arg_2).

[TRY] goal=Ref_75(ken,Ref_77) addr=74
[MATCH] depth=2 goal=Ref_75(ken,Ref_77) clause=dad(ken,adam):., choices_remaining=0
[TRY] goal=pred_1(adam,james) addr=78
[MATCH] depth=2 goal=pred_1(adam,james) clause=P(X,Y):-Q(X,Y)., choices_remaining=3
[ADD_CLAUSE] depth=2 goal=pred_1(adam,james) clause=pred_1(Arg_1,Arg_2):-Ref_95(Arg_1,Arg_2).
[HYPOTHESIS] ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2).
pred_1(Arg_1,Arg_2):-dad(Arg_1,Arg_4),pred_1(Arg_4,Arg_2).
pred_1(Arg_1,Arg_2):-Ref_95(Arg_1,Arg_2).

[TRY] goal=Ref_95(adam,james) addr=94
[MATCH] depth=3 goal=Ref_95(adam,james) clause=dad(adam,james):., choices_remaining=1
[TRY] goal=ancestor(christine,james) addr=44
[MATCH] depth=0 goal=ancestor(christine,james) clause=P(X,Y):-Q(X,Y)., choices_remaining=4
[ADD_CLAUSE] depth=0 goal=ancestor(christine,james) clause=ancestor(Arg_1,Arg_2):-Ref_107(Arg_1,Arg_2).
[HYPOTHESIS] ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2).
pred_1(Arg_1,Arg_2):-dad(Arg_1,Arg_4),pred_1(Arg_4,Arg_2).
pred_1(Arg_1,Arg_2):-dad(Arg_1,Arg_2).
ancestor(Arg_1,Arg_2):-Ref_107(Arg_1,Arg_2).

[TRY] goal=Ref_107(christine,james) addr=106
[NO_MATCH] depth=1 goal=Ref_107(christine,james) tried 7 choices, Originally had 7 choices
[UNDO_TRY] goal=ancestor(christine,james) addr=44
[UNDO_CLAUSE] depth=0 clause=ancestor(Arg_1,Arg_2):-Ref_107(Arg_1,Arg_2).
[RETRY] goal=ancestor(christine,james) addr=44
[MATCH] depth=0 goal=ancestor(christine,james) clause=P(X,Y):-Q(X,Z),P(Z,Y)., choices_remaining=3
[ADD_CLAUSE] depth=0 goal=ancestor(christine,james) clause=ancestor(Arg_1,Arg_2):-Ref_119(Arg_1,Arg_4),ancestor(Arg_4,Arg_2).
[HYPOTHESIS] ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2).
pred_1(Arg_1,Arg_2):-dad(Arg_1,Arg_4),pred_1(Arg_4,Arg_2).
pred_1(Arg_1,Arg_2):-dad(Arg_1,Arg_2).
ancestor(Arg_1,Arg_2):-Ref_119(Arg_1,Arg_4),ancestor(Arg_4,Arg_2).

[TRY] goal=Ref_119(christine,Ref_121) addr=118
[MATCH] depth=1 goal=Ref_119(christine,Ref_121) clause=mum(christine,tami):., choices_remaining=4
[TRY] goal=ancestor(tami,james) addr=122
[MATCH] depth=1 goal=ancestor(tami,james) clause=ancestor(Arg_1,Arg_2):-mum(Arg_1,Arg_4),ancestor(Arg_4,Arg_2)., choices_remaining=3
[TRY] goal=mum(tami,Ref_141) addr=138
[MATCH] depth=2 goal=mum(tami,Ref_141) clause=mum(tami,luke):., choices_remaining=5
[TRY] goal=ancestor(luke,james) addr=142
[MATCH] depth=2 goal=ancestor(luke,james) clause=ancestor(Arg_1,Arg_2):-mum(Arg_1,Arg_4),ancestor(Arg_4,Arg_2)., choices_remaining=3
[TRY] goal=mum(luke,Ref_149) addr=146
[NO_MATCH] depth=3 goal=mum(luke,Ref_149) tried 7 choices, Originally had 7 choices
[UNDO_TRY] goal=ancestor(luke,james) addr=142
[RETRY] goal=ancestor(luke,james) addr=142
[MATCH] depth=2 goal=ancestor(luke,james) clause=ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2)., choices_remaining=0
[TRY] goal=Ref_49(luke,james) addr=154
[NO_MATCH] depth=3 goal=Ref_49(luke,james) tried 7 choices, Originally had 7 choices
[UNDO_TRY] goal=ancestor(luke,james) addr=142
[RETRY] goal=ancestor(luke,james) addr=142
[NO_MATCH] depth=2 goal=ancestor(luke,james) tried 0 choices, Originally had 6 choices
[UNDO_TRY] goal=mum(tami,luke) addr=138
[RETRY] goal=mum(tami,Ref_141) addr=138
[MATCH] depth=2 goal=mum(tami,Ref_141) clause=mum(tami,james):., choices_remaining=4
[RETRY] goal=ancestor(james,james) addr=142
[NO_MATCH] depth=2 goal=ancestor(james,james) tried 0 choices, Originally had 6 choices
[UNDO_TRY] goal=mum(tami,james) addr=138
[RETRY] goal=mum(tami,Ref_141) addr=138
[NO_MATCH] depth=2 goal=mum(tami,Ref_141) tried 4 choices, Originally had 7 choices
[UNDO_TRY] goal=ancestor(tami,james) addr=122
[RETRY] goal=ancestor(tami,james) addr=122
[MATCH] depth=1 goal=ancestor(tami,james) clause=ancestor(Arg_1,Arg_2):-Ref_49(Arg_1,Arg_2)., choices_remaining=0
[TRY] goal=Ref_49(tami,james) addr=158
[MATCH] depth=2 goal=Ref_49(tami,james) clause=mum(tami,james):., choices_remaining=2
